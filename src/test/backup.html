<script>
  document.addEventListener("DOMContentLoaded", function () {
    const API_BASE_URL = "https://dev.gravitywrite.com/api";
    let selectors = [];
    let streamedContent = "";
    let currentIndex = 0;
    let generatedContent = {};
    let defaultContent = {};
    let isFetching = false; // Flag to prevent multiple fetch calls

    // Fetch selectors list
    function fetchSelectorsList(templateName, pageName) {
      if (isFetching) return; // Prevent multiple fetch calls
      isFetching = true;
      return fetch(
        `${API_BASE_URL}/ai/builder/getPageSelector?templatename=${templateName}&page=${pageName}`
      )
        .then((response) => response.json())
        .then((data) => {
          console.log("data's value", data);
          isFetching = false; // Reset fetching flag
          return data.map((selector) => selector.trim());
        })
        .catch((error) => {
          console.error("Error fetching selectors:", error);
          isFetching = false; // Reset fetching flag
          return [];
        });
    }

    // Function to update element with content
    function updateElement(selector, content) {
      const element = document.querySelector(selector);
      if (!element) {
        console.log(`Element with selector "${selector}" not found.`);
        return;
      }

      // Capture the default content if not already captured
      if (!defaultContent[selector]) {
        defaultContent[selector] = element.textContent.trim();
      }

      // Remove the word "data" from the content and also remove newlines
      const cleanedContent = content.replace(/data:/g, "").replace(/\\n/g, "");
      element.textContent = " ";
      element.textContent = cleanedContent;

      // Store the generated content using default content as the key
      generatedContent[defaultContent[selector]] = cleanedContent;
    }

    // Function to automatically scroll to a specific element
    function autoScrollToSelector(selector) {
      const element = document.querySelector(selector);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "center" });
      } else {
        console.log(`Element with selector "${selector}" not found.`);
      }
    }

    // Fetch and stream content
    function fetchStreamedContent(
      templateName,
      pageName,
      businessName,
      description
    ) {
      const prompt = `write website content for ${businessName} and it's description was "${description}", the example is inside the exampleContent tag <exampleContent>Expert Plumbing Services In Chennai- Fast, Reliable, Affordable;At abc plumber, we provide top-notch plumbing services to ensure your home or business is running smoothly. From emergency repairs to routine maintenance, our experienced team is here to help.;Expert Plumbing Services Your Trusted Plumbing Company;In this part, we will introduce you or your business to website visitors. We’ll write about you, your organization, the products or services you offer, and why your company exists.;Our Service;We provide an extensive range of plumbing services. We offer a comprehensive range of plumbing services to meet all your needs.;Emergency Plumbing;Looking for a unique vacation destination? Then maybe a trip to one of the 10 most unique tourist destinations might.;Residential Plumbing;Looking for a unique vacation destination? Then maybe a trip to one of the 10 most unique tourist destinations might.;Water Heater Services;Looking for a unique vacation destination? Then maybe a trip to one of the 10 most unique tourist destinations might.;Commercial Plumbing;Looking for a unique vacation destination? Then maybe a trip to one of the 10 most unique tourist destinations might.;Drain Cleaning;Looking for a unique vacation destination? Then maybe a trip to one of the 10 most unique tourist destinations might.;Bathroom Remodeling;Looking for a unique vacation destination? Then maybe a trip to one of the 10 most unique tourist destinations might.;Why Choose Us;When you choose abc plumber, you’re choosing a company that values;Experience;Years of industry experience ensure we handle any plumbing issue with confidence.;24/7 Availability;Plumbing emergencies don’t wait, and neither do we. Our team is available around the clock to assist you.;Competitive Pricing;We offer top-quality services at prices that fit your budget, without compromising on quality.;What Our Trusted Clients Say;\nCommunity development is often linked with community work or community planning, and may involve stakeholders, foundations,;\"Excellent service! The team was professional, timely, and resolved our plumbing issue quickly. Highly recommend!\";Sarah;Founder;\"I've used for several years and have always been impressed with their work and customer service. They are the best in the business!\";Mark;Founder;\"Their attention to detail and commitment to quality is unmatched. I wouldn't trust anyone else with my plumbing needs.\";Emily W;Founder;\"Their attention to detail and commitment to quality is unmatched. I wouldn't trust anyone else with my plumbing needs.\";Brian;Founder;Need Immediate Plumbing Assistance?;Our team is available 24/7 to provide fast and reliable plumbing services whenever you need them.;</exampleContent>`;

      if (isFetching) return; // Prevent multiple fetch calls
      isFetching = true;
      fetch(`https://ai-builder-backend.onrender.com/StreamIframeController`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt }),
      })
        .then((response) => response.body.getReader())
        .then((reader) => {
          const decoder = new TextDecoder("utf-8");

          function processText({ done, value }) {
            if (done) {
              window.parent.postMessage(
                { type: "generationStatus", isGenerating: false },
                "*"
              );
              window.parent.postMessage(
                {
                  type: "generatedContent",
                  content: generatedContent,
                  pageName,
                },
                "*"
              );
              isFetching = false; // Reset fetching flag
              return;
            }

            streamedContent += decoder.decode(value, { stream: true });
            const contentParts = streamedContent.split(";");

            // First, update all elements with their content
            contentParts.forEach((contentPart, index) => {
              if (index < selectors.length) {
                updateElement(selectors[index], contentPart.trim());
              }
            });

            // Then, handle scrolling sequentially
            if (
              currentIndex < selectors.length &&
              currentIndex < contentParts.length
            ) {
              updateElement(
                selectors[currentIndex],
                contentParts[currentIndex].trim()
              );
              autoScrollToSelector(selectors[currentIndex]);
              currentIndex++;
            }

            // Notify parent that generation is in progress
            window.parent.postMessage(
              { type: "generationStatus", isGenerating: true },
              "*"
            );

            // Continue reading the stream
            reader.read().then(processText);
          }

          reader.read().then(processText);
        })
        .catch((error) => {
          console.error("Error fetching streaming content:", error);
          isFetching = false; // Reset fetching flag
        });
    }

    // Start content generation
    function startContentGeneration(
      templateName,
      pageName,
      businessName,
      description
    ) {
      fetchSelectorsList(templateName, pageName).then((fetchedSelectors) => {
        selectors = fetchedSelectors;
        console.log("Fetched selectors:", selectors);
        currentIndex = 0; // Reset currentIndex when starting
        generatedContent = {}; // Reset generated content
        defaultContent = {}; // Reset default content
        fetchStreamedContent(templateName, pageName, businessName, description);
      });
    }

    // Function to regenerate content
    function regenerateContent(
      templateName,
      pageName,
      businessName,
      description
    ) {
      console.log("Regenerating content based on initial selectors.");
      for (const selector in defaultContent) {
        if (defaultContent.hasOwnProperty(selector)) {
          const element = document.querySelector(selector);
          console.log("element's value:", element);
          if (element) {
            element.textContent = defaultContent[selector]; // Reset to initial content before regeneration
          }
        }
      }
      window.parent.postMessage(
        { type: "regenerateComplete", defaultContent, generatedContent },
        "*"
      );
      fetchStreamedContent(templateName, pageName, businessName, description); // Trigger regeneration
    }

    // Listen for messages from parent
    window.addEventListener("message", function (event) {
      if (event.data.type === "start") {
        const { templateName, pageName, businessName, description } =
          event.data;
        startContentGeneration(
          templateName,
          pageName,
          businessName,
          description
        );
      } else if (event.data.type === "regenerate") {
        regenerateContent(
          event.data.templateName,
          event.data.pageName,
          event.data.businessName,
          event.data.description
        );
      } else if (event.data.type === "changeFont") {
        const link = document.createElement("link");
        link.href = `https://fonts.googleapis.com/css2?family=${event.data.font.replace(
          / /g,
          "+"
        )}&display=swap`;
        link.rel = "stylesheet";
        document.head.appendChild(link);
        document.body.style.fontFamily = event.data.font;
        document.body.setAttribute(
          "style",
          `font-family: ${event.data.font} !important;`
        );
      }
    });

    function updateCSSVariable(variable, value) {
      for (let sheet of document.styleSheets) {
        try {
          for (let rule of sheet.cssRules || sheet.rules) {
            if (rule.style && rule.style.getPropertyValue(variable)) {
              rule.style.setProperty(variable, value);
              return true;
            }
          }
        } catch (e) {
          continue;
        }
      }
      return false;
    }

    window.addEventListener("message", (event) => {
      if (event.data.type === "changeFont") {
        console.log("Font change event triggered");
        const primaryFontFamilyUpdated = updateCSSVariable(
          "--e-global-typography-primary-font-family",
          event.data.font
        );
        if (primaryFontFamilyUpdated) {
          console.log("Primary font family updated to:", event.data.font);
        } else {
          console.log("Primary font family variable not found.");
        }
        document.documentElement.style.setProperty(
          "--gw-primary-font",
          `${event.data.font} !important`
        );
      } else if (event.data.type === "changeGlobalColors") {
        console.log("Color change event triggered");
        const primaryColorUpdated = updateCSSVariable(
          "--e-global-color-primary",
          event.data.primaryColor
        );
        if (primaryColorUpdated) {
          console.log("Primary color updated to:", event.data.primaryColor);
        } else {
          console.log("Primary color variable not found.");
        }
        const secondaryColorUpdated = updateCSSVariable(
          "--e-global-color-secondary",
          event.data.secondaryColor
        );
        if (secondaryColorUpdated) {
          console.log("Secondary color updated to:", event.data.secondaryColor);
        } else {
          console.log("Secondary color variable not found.");
        }
        document.documentElement.style.setProperty(
          "--e-global-color-primary",
          `${event.data.primaryColor} !important`
        );
        document.documentElement.style.setProperty(
          "--e-global-color-secondary",
          `${event.data.secondaryColor} !important`
        );
      }
    });

    window.onload = function () {
      const initialStyles = {
        type: "initialStyles",
        primaryColor: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-color-primary")
          .trim(),
        secondaryColor: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-color-secondary")
          .trim(),
        fontFamily: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-typography-primary-font-family")
          .trim(),
      };
      window.parent.postMessage(initialStyles, "*");
    };
  });
</script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const API_BASE_URL = "https://dev.gravitywrite.com/api";
    let selectors = [];
    let streamedContent = "";
    let currentIndex = 0;
    let generatedContent = {};
    let defaultContent = {};
    let isFetching = false; // Flag to prevent multiple fetch calls

    function fetchSelectorsList(templateName, pageName) {
      if (isFetching) return Promise.resolve([]); // Handle multiple fetch calls gracefully
      isFetching = true;
      return fetch(
        `${API_BASE_URL}/ai/builder/getPageSelector?templatename=${templateName}&page=${pageName}`
      )
        .then((response) => response.json())
        .then((data) => {
          isFetching = false;
          return data.map((selector) => selector.trim());
        })
        .catch((error) => {
          console.error("Error fetching selectors:", error);
          isFetching = false;
          return [];
        });
    }

    function updateElement(selector, content) {
      const element = document.querySelector(selector);
      if (!element) {
        console.log(`Element with selector "${selector}" not found.`);
        return;
      }
      if (!defaultContent[selector]) {
        defaultContent[selector] = element.textContent.trim();
      }
      // 	   autoScrollToSelector(selector);
      element.textContent = "";
      // 	  console.log("this is the content",content);
      element.textContent = content;
      generatedContent[defaultContent[selector]] = content;
    }

    function autoScrollToSelector(selector) {
      const element = document.querySelector(selector);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "center" });
        console.log("autoscroll current element", selector);
      } else {
        console.log("Element with selector `${selector}` not found.");
      }
    }

    function fetchStreamedContent(
      templateName,
      pageName,
      businessName,
      description
    ) {
      if (isFetching) return;
      isFetching = true;
      const url = `${API_BASE_URL}/ai/builder/streamcontent?businessName=${encodeURIComponent(
        businessName
      )}&page_name=${pageName}&description=${description}`;

      const eventSource = new EventSource(url);
      eventSource.onmessage = function (event) {
        const json = JSON.parse(event.data);
        const content = json.choices[0].delta.content; // Extract the content from delta object
        streamedContent += content; // Append new content with a semicolon

        const contentParts = streamedContent.split(";"); // Split content based on semicolons
        contentParts.forEach((part, index) => {
          if (index < selectors.length) {
            updateElement(selectors[index], part.trim());
            let selector = selectors[index];

            autoScrollToSelector(selector);
          }
        });
        currentIndex = (currentIndex + 1) % selectors.length; // Move to the next selector cyclically
      };

      eventSource.onerror = function () {
        console.error("Stream encountered an error");
        isFetching = false;
        eventSource.close();
      };
    }

    window.addEventListener("message", function (event) {
      if (event.data.type === "start") {
        const { templateName, pageName, businessName, description } =
          event.data;
        console.log("description", description);
        fetchSelectorsList(templateName, pageName).then((fetchedSelectors) => {
          selectors = fetchedSelectors;
          currentIndex = 0;
          generatedContent = {};
          defaultContent = {};
          fetchStreamedContent(
            templateName,
            pageName,
            businessName,
            description
          );
        });
      }
    });

    window.onload = function () {
      const initialStyles = {
        type: "initialStyles",
        primaryColor: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-color-primary")
          .trim(),
        secondaryColor: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-color-secondary")
          .trim(),
        fontFamily: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-typography-primary-font-family")
          .trim(),
      };
      window.parent.postMessage(initialStyles, "*");
    };
  });
</script>

//working

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const API_BASE_URL = "https://dev.gravitywrite.com/api";
    let selectors = [];
    let streamedContent = "";
    let currentIndex = 0;
    let generatedContent = {};
    let defaultContent = {};
    let isFetching = false; // Flag to prevent multiple fetch calls
    let lastScrolledSelector = "";

    function fetchSelectorsList(templateName, pageName) {
      if (isFetching) return Promise.resolve([]); // Handle multiple fetch calls gracefully
      isFetching = true;
      return fetch(
        ${API_BASE_URL}/ai/builder/getPageSelector?templatename=${templateName}&page=${pageName}
      )
        .then((response) => response.json())
        .then((data) => {
          isFetching = false;
          return data.map((selector) => selector.trim());
        })
        .catch((error) => {
          console.error("Error fetching selectors:", error);
          isFetching = false;
          return [];
        });
    }

    function updateElement(selector, content) {
      const element = document.querySelector(selector);
      if (!element) {
        console.log(Element with selector "${selector}" not found.);
        return;
      }
      if (!defaultContent[selector]) {
        defaultContent[selector] = element.textContent.trim();
      }
      if (selector !== lastScrolledSelector) {
        autoScrollToSelector(selector);
        lastScrolledSelector = selector; // Update the last scrolled selector
      }

      element.textContent = "";
      element.textContent = content;
      generatedContent[defaultContent[selector]] = content;
    }

    function autoScrollToSelector(selector) {
      const element = document.querySelector(selector);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "center" });
        console.log("autoscroll current element", selector);
      } else {
        console.log(Element with selector "${selector}" not found.);
      }
    }

    function fetchStreamedContent(
      templateName,
      pageName,
      businessName,
      description
    ) {
      if (isFetching) return;
      isFetching = true;
      window.parent.postMessage(
        { type: "generationStatus", isGenerating: true },
        "*"
      );
      const url = ${API_BASE_URL}/ai/builder/streamcontent?businessName=${encodeURIComponent(
        businessName
      )}&page_name=${pageName}&description=${encodeURIComponent(description)};

      const eventSource = new EventSource(url);
      eventSource.onmessage = function (event) {
        const json = JSON.parse(event.data);
        const content = json.choices[0].delta.content; // Extract the content from delta object
        streamedContent += content; // Append new content with a semicolon

        const contentParts = streamedContent.split(";"); // Split content based on semicolons
        contentParts.forEach((part, index) => {
          if (index < selectors.length) {
            updateElement(selectors[index], part.trim());
            let selector = selectors[index];
          }
        });
        currentIndex = (currentIndex + 1) % selectors.length; // Move to the next selector cyclically
      };

      eventSource.onerror = function () {
        console.error("Stream encountered an error");
        isFetching = false;
        eventSource.close();
        window.parent.postMessage(
          { type: "generationStatus", isGenerating: false },
          "*"
        );
        window.parent.postMessage(
          { type: "generatedContent", content: generatedContent, pageName },
          "*"
        );
      };

      eventSource.onopen = function () {
        window.parent.postMessage(
          { type: "generationStatus", isGenerating: true },
          "*"
        );
      };

      eventSource.onclose = function () {
        window.parent.postMessage(
          { type: "generationStatus", isGenerating: false },
          "*"
        );
        window.parent.postMessage(
          { type: "generatedContent", content: generatedContent, pageName },
          "*"
        );
      };
    }

    window.addEventListener("message", function (event) {
      if (event.data.type === "start") {
        const { templateName, pageName, businessName, description } =
          event.data;
        console.log("description", description);
        fetchSelectorsList(templateName, pageName).then((fetchedSelectors) => {
          selectors = fetchedSelectors;
          currentIndex = 0;
          generatedContent = {};
          defaultContent = {};
          fetchStreamedContent(
            templateName,
            pageName,
            businessName,
            description
          );
        });
      } else if (event.data.type === "restoreContent") {
        const { content } = event.data;
        Object.keys(content).forEach((oldContent) => {
          const selector = Object.keys(defaultContent).find(
            (key) => defaultContent[key] === oldContent
          );
          if (selector) {
            updateElement(selector, content[oldContent]);
          }
        });
      }
    });

    function updateCSSVariable(variable, value) {
      for (let sheet of document.styleSheets) {
        try {
          for (let rule of sheet.cssRules || sheet.rules) {
            if (rule.style && rule.style.getPropertyValue(variable)) {
              rule.style.setProperty(variable, value);
              return true;
            }
          }
        } catch (e) {
          continue;
        }
      }
      return false;
    }

    window.addEventListener("message", (event) => {
      if (event.data.type === "changeFont") {
        console.log("Font change event triggered");
        const primaryFontFamilyUpdated = updateCSSVariable(
          "--e-global-typography-primary-font-family",
          event.data.font
        );
        if (primaryFontFamilyUpdated) {
          console.log("Primary font family updated to:", event.data.font);
        } else {
          console.log("Primary font family variable not found.");
          document.body.style.fontFamily = event.data.font;
        }
        document.documentElement.style.setProperty(
          "--gw-primary-font",
          ${event.data.font} !important
        );
        document.body.style.fontFamily = event.data.font; // Hardcode the font family if CSS variable not found
      } else if (event.data.type === "changeGlobalColors") {
        console.log("Color change event triggered");
        const primaryColorUpdated = updateCSSVariable(
          "--e-global-color-primary",
          event.data.primaryColor
        );
        if (primaryColorUpdated) {
          console.log("Primary color updated to:", event.data.primaryColor);
        } else {
          console.log("Primary color variable not found.");
        }
        const secondaryColorUpdated = updateCSSVariable(
          "--e-global-color-secondary",
          event.data.secondaryColor
        );
        if (secondaryColorUpdated) {
          console.log("Secondary color updated to:", event.data.secondaryColor);
        } else {
          console.log("Secondary color variable not found.");
        }
        document.documentElement.style.setProperty(
          "--e-global-color-primary",
          ${event.data.primaryColor} !important
        );
        document.documentElement.style.setProperty(
          "--e-global-color-secondary",
          ${event.data.secondaryColor} !important
        );
      }
    });

    window.onload = function () {
      const initialStyles = {
        type: "initialStyles",
        primaryColor: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-color-primary")
          .trim(),
        secondaryColor: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-color-secondary")
          .trim(),
        fontFamily: getComputedStyle(document.documentElement)
          .getPropertyValue("--e-global-typography-primary-font-family")
          .trim(),
      };
      window.parent.postMessage(initialStyles, "*");
    };
  });
</script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const API_BASE_URL = "https://dev.gravitywrite.com/api";
    let currentIndex = 0;
    let isFetching = false;
    let originalSelectors = [];
    let oldnewcontent = {}; // Object to store old and new content

    function getAllGWSelectors() {
      const elements = document.querySelectorAll("[id^='gw']");
      originalSelectors = Array.from(elements).map(
        (element) => `#${element.id}`
      );
      return originalSelectors;
    }

    async function fetchPageSelectors(gwSelectors) {
      if (isFetching) return [];
      isFetching = true;

      try {
        const response = await fetch(
          `${API_BASE_URL}/ai/builder/getPageSelector`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ selectors: gwSelectors }),
          }
        );

        if (!response.ok) {
          throw new Error(`Error: ${response.status}`);
        }

        const data = await response.json();

        // Collect and store old content before clearing
        data.forEach((item) => {
          const element = document.querySelector(item.id);
          if (element) {
            const oldContent = element.textContent || ""; // Collect old content
            if (item.custom_selector) {
              oldnewcontent = { ...oldnewcontent, [oldContent]: "" };
              element.textContent = ""; // Clear content directly for custom selectors
            } else {
              const targetNode =
                element.children[0]?.children[1] ||
                element.children[0]?.children[0];
              if (targetNode) {
                const targetContent = targetNode.textContent || "";
                oldnewcontent = { ...oldnewcontent, [targetContent]: "" };
                targetNode.textContent = ""; // Clear content of last child
              } else {
                const defaultContent = element.textContent || "";
                oldnewcontent = { ...oldnewcontent, [defaultContent]: "" };
                element.textContent = ""; // Clear content directly if no targetNode found
              }
            }
          }
        });

        return data;
      } catch (error) {
        console.error("Error fetching page selectors:", error);
        return [];
      } finally {
        isFetching = false;
      }
    }

    async function fetchStreamContent(payload, processedSelectors) {
      if (isFetching) return;
      isFetching = true;

      try {
        const response = await fetch(
          `${API_BASE_URL}/ai/builder/streamcontent`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          }
        );

        if (!response.ok) {
          throw new Error(`HTTP status ${response.status}`);
        }

        const reader = response.body.getReader();
        let result = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          result += new TextDecoder("utf-8").decode(value, { stream: true });

          let endIndex;
          while ((endIndex = result.indexOf("~")) !== -1) {
            if (currentIndex >= processedSelectors.length) {
              console.error(
                "Error: Extra content in stream with no available selectors."
              );
              return; // Stop processing as all selectors are used
            }

            let completeData = result.substring(0, endIndex);
            const selectorData = processedSelectors[currentIndex];

            // Send isGenerating: true when content starts typing
            window.parent.postMessage(
              {
                type: "generationStatus",
                isGenerating: true,
              },
              "*"
            );

            await typeEffect(selectorData, completeData);
            scrollToElement(selectorData.id);
            currentIndex++;
            result = result.substring(endIndex + 1);
          }
        }

        // Ensure that the last selector processes any remaining content
        if (
          currentIndex < processedSelectors.length &&
          result.trim().length > 0
        ) {
          const selectorData = processedSelectors[currentIndex];
          await typeEffect(selectorData, result);
          scrollToElement(selectorData.id);
          currentIndex++;
        }

        // After collecting all new content, update the oldnewcontent object
        processedSelectors.forEach((item) => {
          const element = document.querySelector(item.id);
          if (element) {
            let targetNode;
            if (item.custom_selector) {
              targetNode = element;
            } else {
              targetNode =
                element.children[0]?.children[1] ||
                element.children[0]?.children[0];
            }

            if (targetNode && targetNode.nodeName.toLowerCase() !== "style") {
              // Exclude <style> tags
              const newContent = targetNode.textContent || ""; // Collect new content
              const oldContent = Object.keys(oldnewcontent).find(
                (key) => oldnewcontent[key] === ""
              ); // Find the matching old content
              if (oldContent) {
                oldnewcontent[oldContent] = newContent; // Update oldnewcontent with new content
              }
            }
          }
        });

        // Send the entire old and new content to the parent window
        window.parent.postMessage(
          {
            type: "oldNewContent",
            pageName: window.location.pathname.split("/").pop(), // Extract the page name from the URL
            content: oldnewcontent,
          },
          "*"
        );

        // Send the entire HTML content to the parent window
        const pageContent = document.documentElement.outerHTML;
        window.parent.postMessage(
          {
            type: "generatedContent",
            pageName: window.location.pathname.split("/").pop(), // Extract the page name from the URL
            content: pageContent,
            isGenerating: false,
          },
          "*"
        );
      } catch (error) {
        console.error("Streaming data error:", error.message);
      } finally {
        isFetching = false;
        window.parent.postMessage(
          {
            type: "generationStatus",
            isGenerating: false,
          },
          "*"
        );
      }
    }

    async function typeEffect(selectorData, content) {
      const element = document.querySelector(selectorData.id);
      if (!element) {
        return;
      }

      let targetNode;
      if (selectorData.custom_selector) {
        targetNode = element;
      } else {
        targetNode =
          element.children[0]?.children[1] || element.children[0]?.children[0]; // Target the specified structure
      }

      if (!targetNode) {
        return;
      }

      const textNode = targetNode.childNodes[0];
      if (textNode) {
        textNode.nodeValue = ""; // Clear the existing text content
        for (let i = 0; i < content.length; i++) {
          textNode.nodeValue += content.charAt(i);
          await new Promise((resolve) => setTimeout(resolve, 0)); // Typing speed delay
        }
      } else {
        const newText = document.createTextNode("");
        targetNode.appendChild(newText);
        for (let i = 0; i < content.length; i++) {
          newText.nodeValue += content.charAt(i);
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
      }
    }

    function scrollToElement(selector) {
      const element = document.querySelector(selector);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }

    window.addEventListener("message", async function (event) {
      if (event.data.type === "start") {
        // Reset variables for fresh generation
        currentIndex = 0;
        originalSelectors = [];
        oldnewcontent = {};

        const gwSelectors = getAllGWSelectors();
        const processedSelectors = await fetchPageSelectors(gwSelectors);

        fetchStreamContent(
          {
            business_name: event.data.bussinessname || "ajay",
            template_name: event.data.templateName,
            services_provided:
              event.data.description ||
              "At Ajay's restaurant, we offer a diverse menu of authentic Indian cuisine that caters all tastes and preferences. From fragrant and flavorful curries to tandoori specialties and rich biryanis, our menu showcases the vibrant and delicious flavors of India. Our skilled chefs use traditional cooking techniques and quality ingredients to create dishes that are truly unforgettable.In addition to our delectable food offerings, we also provide top-notch customer service in a warm and inviting atmosphere. Whether you are looking to enjoy a cozy dinner with loved ones or host a special celebration, Ajay's restaurant is the perfect setting for any occasion.Come experience the best of Indian cuisine at Ajay's restaurant, where every dish tells a story and every bite is a culinary delight. Join us for a memorable dining experience that will keep you more.",
            customer_steps: "customer needs to visit the website",
            website_category: event.data.category || "restaurant",
            page_name: event.data.pageName,
            selectors: gwSelectors, // Use original selectors
          },
          processedSelectors
        );
      }
    });
    console.log("data:", oldnewcontent);
  });
</script>

<script>
  window.addEventListener("message", (event) => {
    if (event.data.type === "nonClickable") {
      const bodyContent = event.data.transdiv;
      document.body.insertAdjacentHTML("beforeend", bodyContent); // Append content to the body
      console.log(bodyContent, "bodyContent");
    }

    if (event.data.type === "changeLogo") {
      console.log("event received");
      updateLogo(event.data.logoUrl);
    }
  });

  function updateLogo(logoUrl) {
    // Update last <img> in #template-logo
    const parentElement = document.querySelector("#template-logo");
    const images = parentElement.querySelectorAll("img");
    const logoElement = images[images.length - 1];

    console.log("Last image in #template-logo:", logoElement);

    if (logoElement) {
      logoElement.src = logoUrl;
      logoElement.srcset = `${logoUrl} 1x, ${logoUrl} 2x`;
      logoElement.sizes = "(max-width: 319px) 100vw, 319px";
    } else {
      console.warn("Logo element not found in #template-logo.");
    }

    // Update last <img> in #footer-logo
    const footerElement = document.querySelector("#footer-logo");
    const footerImages = footerElement.querySelectorAll("img");
    const footerLogoElement = footerImages[footerImages.length - 1];

    console.log("Last image in #footer-logo:", footerLogoElement);

    if (footerLogoElement) {
      footerLogoElement.src = logoUrl;
      footerLogoElement.srcset = `${logoUrl} 1x, ${logoUrl} 2x`;
      footerLogoElement.sizes = "(max-width: 319px) 100vw, 319px";
    } else {
      console.warn("Logo element not found in #footer-logo.");
    }
  }
</script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    window.addEventListener("message", (event) => {
      if (
        event.data.type === "changeFont" ||
        event.data.type === "changeGlobalColors"
      ) {
        updateCSSVariables(event.data);
      }
    });

    function updateCSSVariables(data) {
      if (data.type === "changeFont") {
        updateCSSVariable(
          "--e-global-typography-primary-font-family",
          data.font
        );
        loadGoogleFont(data.font);
      } else if (data.type === "changeGlobalColors") {
        updateCSSVariable("--e-global-color-primary", data.primaryColor);
        updateCSSVariable("--e-global-color-secondary", data.secondaryColor);
      }
    }
    function injectCSS(variable, value) {
      const style = document.createElement("style");
      style.textContent = ` *{ ${variable}: ${value} !important; }`;
      document.head.appendChild(style);
    }

    function updateCSSVariable(variable, value) {
      let isUpdated = false;
      injectCSS(variable, value);
      for (let sheet of document.styleSheets) {
        try {
          for (let rule of sheet.cssRules || sheet.rules) {
            if (rule.style && rule.style.getPropertyValue(variable)) {
              rule.style.setProperty(variable, value);
              isUpdated = true;
              return true;
            }
          }
        } catch (e) {
          console.log("Error accessing stylesheet:", e);
          continue; // Skip the stylesheet and move on to the next one
        }
      }

      // Fallback to updating the root element if no stylesheet rule was updated
      if (!isUpdated) {
        try {
          injectCSS(variable, value);
          console.log(
            "Design changed using the root element:",
            variable,
            value
          );
          return true;
        } catch (e) {
          console.log("Failed to update CSS variable in the root element:", e);
          return false;
        }
      }
      return false;
    }

    function loadGoogleFont(font) {
      const link = document.createElement("link");
      link.href = `https://fonts.googleapis.com/css2?family=${font.replace(
        / /g,
        "+"
      )}&display=swap`;
      link.rel = "stylesheet";
      document.head.appendChild(link);
      document.body.style.fontFamily = font;
      document.documentElement.style.setProperty(
        "--gw-primary-font",
        `${font} !important`
      );
    }
  });
</script>

<script>
  window.addEventListener("message", function (event) {
    var data = event.data;
    if (data.type === "scroll") {
      handleScrollMessage(data.scrollAmount);
    } else if (data.type === "stopScrolling") {
      stopScrolling();
    } else if (data.type === "reverseScroll") {
      reverseScroll();
    }
  });
  function handleScrollMessage(scrollAmount) {
    document.body.style.transition = "transform 10s linear";
    document.body.style.transform = `translateY(-${
      document.body.scrollHeight - window.innerHeight
    }px)`;
  }
  function stopScrolling() {
    document.body.style.transform = `translateY(${
      document.body.getBoundingClientRect().top
    }px)`;
    document.body.style.transition = "transform 10s linear";
    document.body.style.transform = `translateY(0)`;
  }
  function reverseScroll() {
    var targetPosition = document.body.scrollHeight - window.innerHeight;
    var currentPosition = window.scrollY;
    var step = 10;
    var distance = Math.abs(targetPosition - currentPosition);
    var numSteps = Math.ceil(distance / step);
    var direction = Math.sign(targetPosition - currentPosition);
    var currentStep = 0;
    var scrollIntervalId = setInterval(function () {
      window.scrollBy(0, direction * step);
      currentStep++;
      if (window.scrollY <= 0 || currentStep >= numSteps) {
        clearInterval(scrollIntervalId);
      }
    }, 20);
  }
</script>

<script>
  window.addEventListener("message", function (event) {
    if (event.data.type === "startProcessing") {
      processIds();
    }
  });

  function processIds() {
    const elements = document.querySelectorAll('[id^="gw"]');
    const results = [];

    elements.forEach((el) => {
      const lastChild = el.querySelector(":scope > *:last-child");
      if (lastChild) {
        if (lastChild.tagName.toLowerCase() !== "style") {
          console.log("last child", lastChild.textContent);
          results.push({
            selector: el.id,
            text: lastChild.textContent,
          });
        }
      }
    });

    generatePDF(results);
  }

  function generatePDF(data) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    data.forEach((item, index) => {
      const yPosition = 10 + index * 10;
      doc.text(`Selector: ${item.selector}`, 10, yPosition);
      doc.text(`Text: ${item.text}`, 10, yPosition + 5);
      doc.text(`Console Log: last child ${item.text}`, 10, yPosition + 10);
    });

    doc.save("results.pdf");
  }
</script>

<script>
  // Function to handle incoming messages
  window.addEventListener("message", function (event) {
    // Check the message type
    if (event.data.type === "changeLogo") {
      const logoUrl = event.data.logoUrl;
      // Find the logo element and update its attributes
      const logoElement = document.querySelector(
        "#template-logo > div > div > a > div > div > img"
      );
      console.log("logo element:", logoElement);
      if (logoElement) {
        logoElement.src = logoUrl;
        logoElement.srcset = `${logoUrl} 319w, ${logoUrl} 300w`;
        logoElement.sizes = "(max-width: 319px) 100vw, 319px";
      } else {
        console.warn("Logo element not found.");
      }
    }
  });
</script>

<script>
  window.addEventListener("message", function (event) {
    if (event.data === "fetchGWIDs") {
      const elements = document.querySelectorAll('[id^="gw"]');
      const idsAndContent = Array.from(elements).map((el) => ({
        id: el.id,
        content: el.innerHTML,
      }));
      window.parent.postMessage({ type: "gwIDs", idsAndContent }, "*");
    }
  });
</script>

1.id Collect -> laraval and get correct id list 2.content stream -> ~ switch
3.oldnew content {"old content":"new content"} 4.save html logo font color
scroll
